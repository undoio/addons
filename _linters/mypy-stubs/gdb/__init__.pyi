from __future__ import annotations

from contextlib import AbstractContextManager
from collections.abc import Callable, Generator, Iterable, Iterator, Sequence
from typing import AnyStr, Generic, TypedDict, TypeVar

from typing_extensions import Buffer

# Import the GDB types from src.udbpy.[...], not udbpy.[...] as it's how mypy imports them when
# checking gdb_extensions code.
# That is, if it were imported directly via udbpy, then mypy would complain that
# src.udbpy.gdb_extensions.gdbtypes.Foo is different from udbpy.gdb_extensions.gdbtypes.Foo.
from src.udbpy.gdb_extensions import gdbtypes

from . import events

BP_ACCESS_WATCHPOINT: gdbtypes.BreakpointType
BP_BREAKPOINT: gdbtypes.BreakpointType
BP_HARDWARE_BREAKPOINT: gdbtypes.BreakpointType
BP_HARDWARE_WATCHPOINT: gdbtypes.BreakpointType
BP_NONE: gdbtypes.BreakpointType
BP_READ_WATCHPOINT: gdbtypes.BreakpointType
BP_WATCHPOINT: gdbtypes.BreakpointType
BP_CATCHPOINT: gdbtypes.BreakpointType

COMMAND_BREAKPOINTS: gdbtypes.CommandClassType
COMMAND_DATA: gdbtypes.CommandClassType
COMMAND_FILES: gdbtypes.CommandClassType
COMMAND_MAINTENANCE: gdbtypes.CommandClassType
COMMAND_NONE: gdbtypes.CommandClassType
COMMAND_OBSCURE: gdbtypes.CommandClassType
COMMAND_RUNNING: gdbtypes.CommandClassType
COMMAND_STACK: gdbtypes.CommandClassType
COMMAND_STATUS: gdbtypes.CommandClassType
COMMAND_SUPPORT: gdbtypes.CommandClassType
COMMAND_TRACEPOINTS: gdbtypes.CommandClassType
COMMAND_USER: gdbtypes.CommandClassType

COMPLETE_COMMAND: gdbtypes.CommandCompleteType
COMPLETE_EXPRESSION: gdbtypes.CommandCompleteType
COMPLETE_FILENAME: gdbtypes.CommandCompleteType
COMPLETE_LOCATION: gdbtypes.CommandCompleteType
COMPLETE_NONE: gdbtypes.CommandCompleteType
COMPLETE_SYMBOL: gdbtypes.CommandCompleteType

FRAME_UNWIND_INNER_ID: gdbtypes.FrameUnwindType
FRAME_UNWIND_MEMORY_ERROR: gdbtypes.FrameUnwindType
FRAME_UNWIND_NO_REASON: gdbtypes.FrameUnwindType
FRAME_UNWIND_NO_SAVED_PC: gdbtypes.FrameUnwindType
FRAME_UNWIND_NULL_ID: gdbtypes.FrameUnwindType
FRAME_UNWIND_OUTERMOST: gdbtypes.FrameUnwindType
FRAME_UNWIND_SAME_ID: gdbtypes.FrameUnwindType
FRAME_UNWIND_UNAVAILABLE: gdbtypes.FrameUnwindType

DUMMY_FRAME: gdbtypes.FrameType
INLINE_FRAME: gdbtypes.FrameType
NORMAL_FRAME: gdbtypes.FrameType
ARCH_FRAME: gdbtypes.FrameType
SENTINEL_FRAME: gdbtypes.FrameType
SIGTRAMP_FRAME: gdbtypes.FrameType
TAILCALL_FRAME: gdbtypes.FrameType

PARAM_AUTO_BOOLEAN: gdbtypes.ParameterClassType
PARAM_BOOLEAN: gdbtypes.ParameterClassType
PARAM_ENUM: gdbtypes.ParameterClassType
PARAM_FILENAME: gdbtypes.ParameterClassType
PARAM_INTEGER: gdbtypes.ParameterClassType
PARAM_OPTIONAL_FILENAME: gdbtypes.ParameterClassType
PARAM_STRING: gdbtypes.ParameterClassType
PARAM_STRING_NOESCAPE: gdbtypes.ParameterClassType
PARAM_UINTEGER: gdbtypes.ParameterClassType
PARAM_ZINTEGER: gdbtypes.ParameterClassType
PARAM_ZUINTEGER: gdbtypes.ParameterClassType
PARAM_ZUINTEGER_UNLIMITED: gdbtypes.ParameterClassType

STDERR: gdbtypes.StandardIOType
STDLOG: gdbtypes.StandardIOType
STDOUT: gdbtypes.StandardIOType

SYMBOL_FUNCTIONS_DOMAIN: gdbtypes.SymbolDomainType
SYMBOL_LABEL_DOMAIN: gdbtypes.SymbolDomainType
SYMBOL_STRUCT_DOMAIN: gdbtypes.SymbolDomainType
SYMBOL_TYPES_DOMAIN: gdbtypes.SymbolDomainType
SYMBOL_UNDEF_DOMAIN: gdbtypes.SymbolDomainType
SYMBOL_VARIABLES_DOMAIN: gdbtypes.SymbolDomainType
SYMBOL_VAR_DOMAIN: gdbtypes.SymbolDomainType

SYMBOL_LOC_ARG: gdbtypes.SymbolAddressClassType
SYMBOL_LOC_BLOCK: gdbtypes.SymbolAddressClassType
SYMBOL_LOC_COMPUTED: gdbtypes.SymbolAddressClassType
SYMBOL_LOC_CONST: gdbtypes.SymbolAddressClassType
SYMBOL_LOC_CONST_BYTES: gdbtypes.SymbolAddressClassType
SYMBOL_LOC_LABEL: gdbtypes.SymbolAddressClassType
SYMBOL_LOC_LOCAL: gdbtypes.SymbolAddressClassType
SYMBOL_LOC_OPTIMIZED_OUT: gdbtypes.SymbolAddressClassType
SYMBOL_LOC_REF_ARG: gdbtypes.SymbolAddressClassType
SYMBOL_LOC_REGISTER: gdbtypes.SymbolAddressClassType
SYMBOL_LOC_REGPARM_ADDR: gdbtypes.SymbolAddressClassType
SYMBOL_LOC_STATIC: gdbtypes.SymbolAddressClassType
SYMBOL_LOC_TYPEDEF: gdbtypes.SymbolAddressClassType
SYMBOL_LOC_UNDEF: gdbtypes.SymbolAddressClassType
SYMBOL_LOC_UNRESOLVED: gdbtypes.SymbolAddressClassType

TYPE_CODE_ARRAY: gdbtypes.ValueTypeCodeType
TYPE_CODE_BITSTRING: gdbtypes.ValueTypeCodeType
TYPE_CODE_BOOL: gdbtypes.ValueTypeCodeType
TYPE_CODE_CHAR: gdbtypes.ValueTypeCodeType
TYPE_CODE_COMPLEX: gdbtypes.ValueTypeCodeType
TYPE_CODE_DECFLOAT: gdbtypes.ValueTypeCodeType
TYPE_CODE_ENUM: gdbtypes.ValueTypeCodeType
TYPE_CODE_ERROR: gdbtypes.ValueTypeCodeType
TYPE_CODE_FLAGS: gdbtypes.ValueTypeCodeType
TYPE_CODE_FLT: gdbtypes.ValueTypeCodeType
TYPE_CODE_FUNC: gdbtypes.ValueTypeCodeType
TYPE_CODE_INT: gdbtypes.ValueTypeCodeType
TYPE_CODE_INTERNAL_FUNCTION: gdbtypes.ValueTypeCodeType
TYPE_CODE_MEMBERPTR: gdbtypes.ValueTypeCodeType
TYPE_CODE_METHOD: gdbtypes.ValueTypeCodeType
TYPE_CODE_METHODPTR: gdbtypes.ValueTypeCodeType
TYPE_CODE_NAMESPACE: gdbtypes.ValueTypeCodeType
TYPE_CODE_PTR: gdbtypes.ValueTypeCodeType
TYPE_CODE_RANGE: gdbtypes.ValueTypeCodeType
TYPE_CODE_REF: gdbtypes.ValueTypeCodeType
TYPE_CODE_RVALUE_REF: gdbtypes.ValueTypeCodeType
TYPE_CODE_SET: gdbtypes.ValueTypeCodeType
TYPE_CODE_STRING: gdbtypes.ValueTypeCodeType
TYPE_CODE_STRUCT: gdbtypes.ValueTypeCodeType
TYPE_CODE_TYPEDEF: gdbtypes.ValueTypeCodeType
TYPE_CODE_UNION: gdbtypes.ValueTypeCodeType
TYPE_CODE_VOID: gdbtypes.ValueTypeCodeType

WP_ACCESS: gdbtypes.WatchPointType
WP_READ: gdbtypes.WatchPointType
WP_WRITE: gdbtypes.WatchPointType

HOST_CONFIG: str
TARGET_CONFIG: str
VERSION: str

prompt_hook: Callable[[str], str] | None
pretty_printers: list[gdbtypes.PrettyPrinterFunc]

class error(RuntimeError): ...
class MemoryError(error): ...
class GdbError(Exception): ...
class Function: ...
class Membuf: ...
class PendingFrame: ...
class TypeIterator: ...
class UnwindInfo: ...

class Field:
    name: str | None
    artificial: bool
    is_base_class: bool
    bitsize: int
    type: Type | None
    parent_type: Type

    # The following are not always available, but there's no way to express this.
    bitpos: int | None
    enumval: int

class RegisterDescriptorIterator:
    def __iter__(self) -> Iterator[RegisterDescriptor]: ...
    def find(self, name: str) -> RegisterDescriptor | None: ...

class RegisterDescriptor:
    name: str

class RegisterGroupsIterator:
    def __iter__(self) -> Iterator[RegisterGroup]: ...

class RegisterGroup:
    name: str

class _Disassembly(TypedDict):
    addr: int
    asm: str
    length: int

class Architecture:
    def name(self) -> str: ...
    def disassemble(
        self,
        start_pc: int,
        end_pc: int = ...,
        count: int = ...,
    ) -> list[_Disassembly]: ...
    def registers(self, reggroup: str = ...) -> RegisterDescriptorIterator: ...
    def register_groups(self) -> RegisterGroupsIterator: ...

class Block:
    start: int
    end: int
    function: Symbol | None
    superblock: Block | None
    global_block: Block
    static_block: Block
    is_global: bool
    is_static: bool
    def is_valid(self) -> bool: ...
    def __iter__(self) -> Iterator[Symbol]: ...

_T = TypeVar("_T")

class Parameter(Generic[_T]):
    value: _T
    def __init__(
        self,
        name: str,
        command_class: gdbtypes.CommandClassType,
        parameter_class: gdbtypes.ParameterClassType,
        enum_sequence: Sequence[str] = ...,
    ) -> None: ...

class Type:
    alignof: int
    code: gdbtypes.ValueTypeCodeType
    dynamic: bool
    name: str | None
    objfile: Objfile | None
    sizeof: int | None
    tag: str | None
    def array(self, n1: int, n2: int = ...) -> Type: ...
    def const(self) -> Type: ...
    def fields(self) -> Sequence[Field]: ...
    def optimized_out(self) -> Value: ...
    def pointer(self) -> Type: ...
    def range(self) -> tuple[int, int]: ...
    def reference(self) -> Type: ...
    def strip_typedefs(self) -> Type: ...
    def target(self) -> Type: ...
    def template_argument(self, n: int, block: Block = ...) -> Value | Type: ...
    def unqualified(self) -> Type: ...
    def vector(self, n1: int, n2: int = ...) -> Type: ...
    def volatile(self) -> Type: ...

class Value:
    address: Value | None
    dynamic_type: Type
    is_lazy: bool
    is_optimized_out: bool
    type: Type
    def __init__(self, Val: object) -> None: ...
    def __add__(self, other: object) -> Value: ...
    def __abs__(self) -> Value: ...
    def __and__(self, other: object) -> Value: ...
    def __bool__(self, other: object) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __float__(self) -> float: ...
    def __getitem__(self, _n: object) -> Value: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> Value: ...
    def __lshift__(self, other: object) -> Value: ...
    def __mul__(self, other: object) -> Value: ...
    def __neg__(self) -> Value: ...
    def __or__(self, other: object) -> Value: ...
    def __pos__(self) -> Value: ...
    def __pow__(self, other: object) -> Value: ...
    def __rshift__(self, other: object) -> Value: ...
    def __sub__(self, other: object) -> Value: ...
    def __truediv__(self, other: object) -> Value: ...
    def __xor__(self, other: object) -> Value: ...
    def cast(self, type: Type) -> Value: ...
    def dereference(self) -> Value: ...
    def dynamic_cast(self, type: Type) -> Value: ...
    def fetch_lazy(self) -> None: ...
    def format_string(self, *args: object, **kwargs: object) -> str: ...
    def referenced_value(self) -> Value: ...
    def reinterpret_cast(self, type: Type) -> Value: ...
    def string(self, encoding: str = ..., errors: str = ..., length: int = ...) -> str: ...

class BreakpointLocation:
    source: tuple[str, int]
    address: int
    enabled: bool
    owner: Breakpoint
    function: str | None
    fullname: str | None
    thread_groups: list[int]

class Breakpoint:
    enabled: bool
    silent: bool
    pending: bool
    thread: int | None
    task: object | None
    ignore_count: int
    number: int
    type: gdbtypes.BreakpointType
    visible: bool
    temporary: bool
    hit_count: int
    location: str | None
    locations: list[BreakpointLocation]
    expression: str | None
    condition: str | None
    commands: str | None
    def __init__(
        self,
        spec: str = ...,
        type: gdbtypes.BreakpointType = ...,
        wp_class: gdbtypes.WatchPointType = ...,
        internal: bool = ...,
        temporary: bool = ...,
        qualified: bool = ...,
        source: str = ...,
        function: str = ...,
        label: str = ...,
        line: int = ...,
    ) -> None: ...
    def stop(self) -> bool: ...
    def is_valid(self) -> bool: ...
    def delete(self) -> None: ...

class FinishBreakpoint(Breakpoint):
    return_value: Value | None

    def __init__(self, frame: Frame = ..., internal: bool = ...) -> None: ...
    def out_of_scope(self) -> None: ...

class Symbol:
    type: Type
    symtab: Symtab
    line: int
    name: str
    linkage_name: str
    print_name: str
    add_class: gdbtypes.SymbolAddressClassType
    needs_frame: bool
    is_argument: bool
    is_constant: bool
    is_function: bool
    is_variable: bool
    def is_valid(self) -> bool: ...
    def value(self, frame: Frame = ...) -> Value: ...

class Frame:
    def is_valid(self) -> bool: ...
    def name(self) -> str | None: ...
    def architecture(self) -> Architecture: ...
    def type(self) -> int: ...
    def unwind_stop_reason(self) -> int: ...
    def pc(self) -> int: ...
    def block(self) -> Block: ...
    def function(self) -> Symbol | None: ...
    def older(self) -> Frame | None: ...
    def newer(self) -> Frame | None: ...
    def range(self) -> tuple[int, int]: ...
    def read_register(self, register: str) -> Value: ...
    def read_var(self, variable: str | Symbol, block: Block = ...) -> Value: ...
    def select(self) -> None: ...
    def find_sal(self) -> Symtab_and_line: ...
    def is_marked_for_skip(self) -> bool: ...
    def level(self) -> int: ...
    def language(self) -> str: ...

class Progspace:
    filename: str | None
    pretty_printers: list[gdbtypes.PrettyPrinterFunc]
    def block_for_pc(self, pc: int) -> Block | None: ...
    def find_pc_line(self, pc: int) -> Symtab_and_line: ...
    def is_valid(self) -> bool: ...
    def objfiles(self) -> list[Objfile]: ...
    def solib_name(self, address: int) -> str | None: ...

class LineTableEntry:
    line: int
    pc: int
    is_stmt: int

class LineTable:
    def __iter__(self) -> Generator[LineTableEntry, None, None]: ...
    def line(self, line: int) -> Iterable[LineTableEntry] | None: ...
    def has_line(self, line: int) -> bool: ...
    def source_lines(self) -> list[int]: ...

class LineTableIterator: ...

class Objfile:
    filename: str | None
    username: str | None
    owner: Objfile | None
    build_id: str | None
    progspace: Progspace
    pretty_printers: list[gdbtypes.PrettyPrinterFunc]
    def is_valid(self) -> bool: ...
    def add_separate_debug_file(self, file: str) -> None: ...

class Symtab:
    filename: str
    objfile: Objfile
    producer: str | None
    def is_valid(self) -> bool: ...
    def fullname(self) -> str: ...
    def global_block(self) -> Block: ...
    def static_block(self) -> Block: ...
    def linetable(self) -> LineTable: ...

class Symtab_and_line:
    symtab: Symtab | None
    pc: int
    last: int | None
    line: int
    def is_valid(self) -> bool: ...

class TargetConnection:
    num: int
    type: str
    details: str | None

    def is_valid(self) -> bool: ...
    def send_packet(self, packet: AnyStr) -> bytes: ...

class RemoteTargetConnection(TargetConnection):
    pass

class Inferior:
    num: int
    pid: int
    was_attached: bool
    progspace: Progspace
    connection: TargetConnection | None
    def is_valid(self) -> bool: ...
    def threads(self) -> tuple[InferiorThread, ...]: ...
    def architecture(self) -> Architecture: ...
    def read_memory(self, address: int, length: int) -> memoryview: ...
    def write_memory(self, address: int, buffer: Buffer, length: int = ...) -> None: ...
    def search_memory(self, address: int, length: int, pattern: Buffer) -> int | None: ...

class InferiorThread:
    name: str | None
    num: int
    global_num: int
    ptid: tuple[int, int, int]
    inferior: Inferior
    def is_valid(self) -> bool: ...
    def switch(self) -> None: ...
    def is_stopped(self) -> bool: ...
    def is_running(self) -> bool: ...
    def is_exited(self) -> bool: ...
    def handle(self) -> bytes: ...

class EventRegistry:
    def connect(self, function: gdbtypes.EventFunction) -> None: ...
    def disconnect(self, function: gdbtypes.EventFunction) -> None: ...

class Event: ...
class ClearObjFilesEvent(Event): ...
class ExitedEvent(Event): ...

class GdbExitingEvent(Event):
    exit_code: int

class InferiorCallPostEvent(Event): ...
class InferiorCallPreEvent(Event): ...
class MemoryChangedEvent(Event): ...
class RegisterChangedEvent(Event): ...
class ThreadEvent(Event): ...
class ContinueEvent(ThreadEvent): ...

class NewThreadEvent(ThreadEvent):
    # This should be a thread but, due to https://sourceware.org/bugzilla/show_bug.cgi?id=28429,
    # it's an inferior in some GDB versions.
    inferior_thread: InferiorThread | Inferior

class StopEvent(ThreadEvent): ...

class BreakpointEvent(StopEvent):
    breakpoints: list[Breakpoint]

class SignalEvent(StopEvent): ...

class NewObjFileEvent(Event):
    new_objfile: Objfile

class InferiorDeletedEvent(Event):
    inferior: Inferior

class NewInferiorEvent(Event):
    inferior: Inferior

class ConnectionEvent(Event):
    connection: TargetConnection

class Command:
    def __init__(
        self,
        name: str,
        command_class: gdbtypes.CommandClassType = ...,
        completer_class: gdbtypes.CommandCompleteType = ...,
        prefix: bool = ...,
        rename_existing_to: str = ...,
    ) -> None: ...
    def dont_repeat(self) -> None: ...
    def invoke(self, argument: str, from_tty: bool) -> None: ...
    def complete(self, text: str, word: str) -> gdbtypes.CompleteResult: ...

# The following class is provided only for use with `isinstance` and not to be used directly,
# so methods are not listed on purpose.

class _GdbFile:
    pass

# The correct signature for gdb.execute (in upstream GDB) is:
#     def execute(command: str, from_tty: bool = ..., from_string: bool = ...) -> str | None: ...
# With the return value being a string if the to_string argument is true, otherwise it's None.
#
# In our code, we don't want to accidentally use gdb.execute(..., to_string=True) as that doesn't
# produce the expected output if command tracing is on (see help set trace-commands). Instead, we
# must use gdbutils.execute_to_string.
# To avoid accidental usages of the to_string parameter, we just pretend it doesn't exist and that
# the return value is always None.
#
# Our bundled GDB also accepts a boolean argument called styled (see
# https://sourceware.org/pipermail/gdb-patches/2020-December/174340.html), but we don't include
# it here for the same reason as for the `to_string` argument.
def execute(command: str, from_tty: bool = ...) -> None: ...
def block_for_pc(pc: int) -> Block | None: ...
def breakpoints() -> Iterable[Breakpoint]: ...
def current_objfile() -> Objfile | None: ...
def current_progspace() -> Progspace: ...
def default_visualizer(value: Value) -> object: ...
def find_pc_line(pc: int) -> Symtab_and_line: ...
def flush(stream: gdbtypes.StandardIOType = ...) -> None: ...
def find_pc_compunit_symtabs(pc: int) -> list[Symtab]: ...
def inferiors() -> list[Inferior]: ...
def lookup_global_symbol(
    name: str, domain: gdbtypes.SymbolDomainType = ...
) -> tuple[Symbol | None, bool]: ...
def lookup_objfile(name: str, by_build_id: bool = ...) -> Objfile | None: ...
def lookup_symbol(
    name: str, block: Block = ..., domain: gdbtypes.SymbolDomainType = ...
) -> tuple[Symbol | None, bool]: ...
def lookup_type(name: str, block: Block | None = ...) -> Type: ...
def newest_frame() -> Frame: ...
def objfiles() -> Iterable[Objfile]: ...
def parameter(parameter: str) -> object: ...
def set_parameter(name: str, value: object) -> None: ...
def parse_and_eval(expression: str) -> Value: ...
def post_event(event: Callable[[], None]) -> None: ...
def progspaces() -> list[Progspace]: ...
def selected_frame() -> Frame: ...
def selected_inferior() -> Inferior: ...
def selected_thread() -> InferiorThread | None: ...
def set_convenience_variable(name: str, value: object) -> None: ...
def string_to_argv(arg: str) -> list[str]: ...
def with_parameter(name: str, value: object) -> AbstractContextManager[None]: ...
def write(string: str, stream: gdbtypes.StandardIOType = ...) -> None: ...
def _execute_file(filepath: str) -> None: ...
def register_window_type(name: str, factory: gdbtypes.TuiWindowFactory) -> None: ...
